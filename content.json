{"meta":{"title":"lorz5の小さい家","subtitle":"Personal Website","description":"ー頑張ろうねー","author":"lorz5","url":"https://lorz5.github.io","root":"/"},"pages":[{"title":"404","date":"2020-04-01T02:00:45.000Z","updated":"2020-04-01T02:00:45.830Z","comments":true,"path":"404/index.html","permalink":"https://lorz5.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2020-04-01T02:00:33.000Z","updated":"2020-04-01T02:00:33.237Z","comments":true,"path":"search/index.html","permalink":"https://lorz5.github.io/search/index.html","excerpt":"","text":""},{"title":"about","date":"2020-04-01T07:23:25.000Z","updated":"2020-04-01T07:25:31.498Z","comments":true,"path":"about/index.html","permalink":"https://lorz5.github.io/about/index.html","excerpt":"","text":"一个渴望能飞起来的小蚂蚁 正在努力向前爬…"}],"posts":[{"title":"c++之const修饰符","slug":"c-之const修饰符","date":"2020-04-14T14:13:37.000Z","updated":"2020-04-14T16:28:53.119Z","comments":true,"path":"2020/04/14/c-之const修饰符/","link":"","permalink":"https://lorz5.github.io/2020/04/14/c-%E4%B9%8Bconst%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"C++之const修饰符 关于C++ const的全面总结 一、基本概念和知识点 在C语言中，我们通常使用#define去进行预定义的某个数（不为其分配内存），在编译预处理过程中就会用定义好的常量字面数据去替换文中的某个符号。 与C语言不同的是，C++中通常使用const修饰符去代替C语言中的#define，一般情况下编译器也是不为const创建空间的，只是将这个定义的数字保存在符号表中。 C++会对const进行优化，以尽量避免为其分配内存。 被const修饰的类型称为常类型，常类型的变量或对象的值是不能被更新的。 二、const的基本使用1、定义常量内部：const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。 # include using namespace std; int main() { const int a = 1; // 必须在定义的同时进行初始化 int const b = 2 + 1; // 两种声明方式均可，效果相同 // a = 1; error","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://lorz5.github.io/tags/c/"}]},{"title":"C++的对象指针","slug":"C++的对象指针","date":"2020-04-09T12:19:06.000Z","updated":"2020-04-09T15:23:48.003Z","comments":true,"path":"2020/04/09/C++的对象指针/","link":"","permalink":"https://lorz5.github.io/2020/04/09/C++%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/","excerpt":"","text":"C++中的的对象指针指针...懂得都懂 一、指向对象的指针# include using namespace std; class A { public: A(){} }; int main() { // name 即为一个对象指针，此时指向一个类型为A的对象 A * name = new A; return 0; } 二、指向对象成员的指针对象由成员构成，一整个对象的总内存为各个数据成员占据的内存区的总和。 那么对象的成员也有地址，指向对象成员地址的指针变量即为指向对象成员的指针 1、指向对象公有数据成员# include using namespace std; class A { public: int num; A(){ num = 1; } }; int main() { A aa; int * p = &aa.num; // 指针变量p指向aa这个对象的成员数据num return 0; } 2、指向对象成员函数 先复习一下普通情况下一个指向函数的指针是什么样子的 数据类型名 （*指针变量名)(参数列表）； 例如： void (*p)( ); //p指向void型函数的指针变量； ​ p = fun; //fun入口地址赋予p； ​ (*p)( ); //调用fun函数； # include # include using namespace std; void make(string str) { cout < str < endl; } int main() { void (*p) (string) = make; (*p)(\"你好\"); return 0; } /* 输出结果： > 你好 */","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://lorz5.github.io/tags/c/"}]},{"title":"C++中的内存区域","slug":"C++中的内存区域","date":"2020-04-09T09:03:33.000Z","updated":"2020-04-09T14:25:33.644Z","comments":true,"path":"2020/04/09/C++中的内存区域/","link":"","permalink":"https://lorz5.github.io/2020/04/09/C++%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"C++中的内存区域C++的内存区域大致分为5个小区域 分别为 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap）— 由程序员负责分配和释放，与数据结构中的堆是两回事 全局区（静态区）— 存放全局变量和静态变量。 初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放。 文字常量区（常量池） — 常量字符串就是放在这里的。 程序结束后由系统释放 程序代码区 — 存放函数体的二进制代码。 堆和栈的申请方式栈由系统自动分配，速度较快，在windows下栈是向低地址扩展的数据结构，是一块连续的内存区域，大小是2MB。 堆需要程序员自己申请，并指明大小，速度比较慢。在C中用malloc，C++中用new。另外，堆是向高地址扩展的数据结构，是不连续的内存区域，堆的大小受限于计算机的虚拟内存。因此堆空间获取和使用比较灵活，可用空间较大。","categories":[],"tags":[{"name":"底层","slug":"底层","permalink":"https://lorz5.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"c++","slug":"c","permalink":"https://lorz5.github.io/tags/c/"}]},{"title":"Java中jvm的内存区域","slug":"Java中jvm的内存区域","date":"2020-04-09T08:40:00.000Z","updated":"2020-04-09T09:15:21.092Z","comments":true,"path":"2020/04/09/Java中jvm的内存区域/","link":"","permalink":"https://lorz5.github.io/2020/04/09/Java%E4%B8%ADjvm%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"Java中jvm的内存区域java中的jvm将内存一共分成了四个区域 栈区（stack segment） 堆区（heap segment） 代码区（code segment） 数据区（data segment） 一、栈区栈中保存基本数据类型的变量和自定义的对象的引用(而不是对象)，对象本身都存放在堆区中，被执行的方法的也是pull到栈中，当方法执行完后再push出栈。 栈区(stack)：由系统的编译器自动的释放，主要用来存放方法中的参数，一些临时的局部变量等，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。 class A { int num; public void say(){ } } public class Main { public static void main(String[] args) { // aa存储在栈区 // aa指向的内存存放在堆区 A aa = new A(); } } 二、堆区当new一个对象的时候，这个对象就被存储在了堆区中。 由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来存放我们经常创建的对象、动态的申请的临时空间等。 三、代码区存放程序编译后可以执行代码的地方。比如执行代码时写的While语句、if条件语句、方法等，都会存放到此。 四、数据区也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的静态变量、全局变量等都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。","categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"},{"name":"底层","slug":"底层","permalink":"https://lorz5.github.io/tags/%E5%BA%95%E5%B1%82/"}]},{"title":"Java中的匿名内部类","slug":"Java中的匿名内部类","date":"2020-04-08T14:59:54.000Z","updated":"2020-04-08T15:51:23.808Z","comments":true,"path":"2020/04/08/Java中的匿名内部类/","link":"","permalink":"https://lorz5.github.io/2020/04/08/Java%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"Java中的匿名内部类与代码块代码块用途：用于初始化类成员属性 具体使用方法： public class Main { public int age; public static String name; // 非静态代码块 { age = 1; double money = 100; System.out.println(\"~执行了非静态代码块~\"); } // 静态代码块 static { // age = 10; // error，静态代码块只能对静态属性进行操作 name = \"lorz5\"; System.out.println(\"~执行了静态代码块~\"); } public static void main(String[] args) { // 实例化两次，静态代码块只会初始化一次 Main a = new Main(); Main b = new Main(); } } /* 输出结果： > ~执行了静态代码块~ > ~执行了非静态代码块~ > ~执行了非静态代码块~ */ 静态代码块只能对静态属性进行操作 静态代码块只会初始化一次 静态代码块优先于非静态代码块 匿名内部类匿名内部类即没有名字的内部类，只能使用一次 前提条件：必须继承一个父类或实现一个接口 用途：简化代码编写 使用方法1、匿名内部类实现抽象方法abstract class A { int num; public abstract void say(); } public class Main { public static void main(String[] args) { // 创建的匿名内部类为A的子类 A aa = new A() { {// 因为没有类名，所以没有构造函数，作为代替，可以使用代码块来初始化 super.num = 1; } public void say(){ System.out.println(\"Hello\"); } }; aa.say(); } } /* 输出结果： > Hello */ 2、匿名内部类实现接口interface A { void say(); } public class Main { public static void main(String[] args) { A aa = new A() { public void say(){ System.out.println(\"Hello\"); } }; aa.say(); } } /* 输出结果： > Hello */ 3、Thread类的匿名内部类实现public class Demo { public static void main(String[] args) { Thread t = new Thread() { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.print(i + \" \"); } } }; t.start(); } } /* 输出结果： > 1 2 3 4 5 */ 4、Runnable接口的匿名内部类实现public class Demo { public static void main(String[] args) { Runnable r = new Runnable() { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.print(i + \" \"); } } }; Thread t = new Thread(r); t.start(); } } /* 输出结果： > 1 2 3 4 5 */","categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"}]},{"title":"Java中的equals方法","slug":"Java中的equals方法","date":"2020-04-08T12:21:32.000Z","updated":"2020-04-08T12:49:38.929Z","comments":true,"path":"2020/04/08/Java中的equals方法/","link":"","permalink":"https://lorz5.github.io/2020/04/08/Java%E4%B8%AD%E7%9A%84equals%E6%96%B9%E6%B3%95/","excerpt":"","text":"java中的equals方法小结Java中比较两个对象有两种方式 一、==操作符 这个用来比较两个对象是否为同一对象 原理：实质比较的是变量(栈)内存中存放的对象的(堆)内存地址 真正意义上的指针操作。 public class Main { public static void main(String[] args) { Father a = new Father(); Father b = new Father(); System.out.println(a == b); // false，不是同一对象 } } 二、equals()方法 涉及到的常识：所有类都继承Object，也就拥有了从Object中得到的equals()方法 /* 底层源码 */ public boolean equals(Object obj) { return (this == obj); } 传统的equals()方法与==操作符作用一样，只能比较是否指向同一对象 特例：当用equals()方法进行比较时，对File、Date和各种包装类（Integer、Double、String等等）来说，比较的是类型和内容是否一致而不考虑引用的是否是同一对象（原因：重写了equals()方法） public class Main { public static void main(String[] args) { String a = new String(\"123\"); String b = new String(\"123\"); System.out.println(a == b); // false，不同的两个对象 System.out.println(a.equals(b)); // true，两个对象内容相同 } } 三、补充小知识 java中的jvm将内存粗略的分成三个区，分别为栈区、堆区和常量池 变量存放的内存为栈区，动态分配的内存（new）的则在堆区 定义的常量只会存在一个，存放在常量池中 public class Main { public static void main(String[] args) { String a = \"abc\"; // 在常量池中创建了一个\"abc\"的对象 String b = \"abc\"; // 常量池中已存在同样的为“abc”的对象，直接将其赋给当前引用 System.out.println(a == b); // true，同一个对象 System.out.println(a.equals(b)); // true，两个对象内容相同 } } 另外，==比较运算比使用equals()方法快","categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"}]},{"title":"常用doc命令","slug":"常用doc命令","date":"2020-04-06T16:25:45.000Z","updated":"2020-04-06T16:31:36.172Z","comments":true,"path":"2020/04/07/常用doc命令/","link":"","permalink":"https://lorz5.github.io/2020/04/07/%E5%B8%B8%E7%94%A8doc%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用的doc命令dir：列出当前目录下的文件以及文件夹 md：创建一个文件夹 rd：删除一个文件夹 cd：进入指定目录 cd..：返回上一级目录 cd\\：退回到根目录 del：删除文件 exit：退出doc命令行","categories":[],"tags":[{"name":"doc","slug":"doc","permalink":"https://lorz5.github.io/tags/doc/"}]},{"title":"开始学习MySQL","slug":"开始学习MySQL","date":"2020-04-03T12:09:06.000Z","updated":"2020-04-09T15:24:15.940Z","comments":true,"path":"2020/04/03/开始学习MySQL/","link":"","permalink":"https://lorz5.github.io/2020/04/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0MySQL/","excerpt":"","text":"MySQL一、从安装开始 安装地址：https://dev.mysql.com/downloads/mysql/ 1、挑选合适的版本安装（建议以压缩包的形式） 2、建议放在电脑的环境配置下 3、配置环境变量 我的电脑 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; Path路径 -&gt; 编辑，添加bin目录 4、新建mysql配置文件 [mysqld] basedir=D:\\Environment\\mysql-8.0.19\\ datadir=D:\\Environment\\mysql-8.0.19\\data\\ port=3306 #端口 skip-grant-tables #跳过密码验证 5、启动管理员模式下的CMD，切换到mysql下的bin目录，输入mysqld -install （安装mysql）","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lorz5.github.io/tags/MySQL/"}]},{"title":"23种设计模式之单例模式","slug":"23种设计模式之单例模式","date":"2020-04-01T08:11:23.000Z","updated":"2020-04-01T08:19:43.818Z","comments":true,"path":"2020/04/01/23种设计模式之单例模式/","link":"","permalink":"https://lorz5.github.io/2020/04/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式参考： https://how2j.cn/k/class-object/class-object-singleton/349.html#nowhere https://www.bilibili.com/video/av68172551 https://blog.csdn.net/baolingye/article/details/101106783 核心作用 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点 优点 单例模式只生成一个实例，减少系统的性能开销 单例模式可以在系统设置全局访问点，优化共享资源访问 常见的五种单例模式实现一、饿汉式 特点：线程安全，调用效率高，不能延时加载 缺点：无论这个类有没有被调用到，都会首先加载里面的资源，占用一定的内存空间，如果这个类长时间没有被用到，那么容易会造成空间浪费的结果。 /* 精髓所在 */ public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取第7行定义的对象 public static GiantDragon getInstance(){ return instance; } } /* 测试，后面相同 */ public class TestGiantDragon { public static void main(String[] args) { //通过new实例化会报错 // GiantDragon g = new GiantDragon(); //只能通过getInstance得到对象 GiantDragon g1 = GiantDragon.getInstance(); GiantDragon g2 = GiantDragon.getInstance(); GiantDragon g3 = GiantDragon.getInstance(); //都是同一个对象 System.out.println(g1==g2); // true System.out.println(g1==g3); // true } } 二、懒汉式 懒汉式单例模式与饿汉式单例模式不同，只有在调用这个类的时候，才会创建实例 特点：线程安全，调用效率不高，可以延时加载 缺点：效率较低 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //准备一个类属性，用于指向一个实例化对象，但是暂时不创建内存空间，令其指向null private static GiantDragon instance; //public static 方法，返回实例对象 // 若存在并发，可添加synchronized修饰符 public static GiantDragon getInstance(){ //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance){ instance = new GiantDragon(); } //返回 instance指向的对象 return instance; } } 三、DCL懒汉式（双重检测锁模式） 特点：不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率 缺点：因为不是在类加载时就创建对象，因此存在线程安全问题，当第一个线程执行到创建对象的方法时，但还未出方法返回，此时第二个线程进入，发现instance不为空，但第一个线程此时还未出去，可能发送意想不到的安全问题 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //准备一个类属性，用于指向一个实例化对象，但是暂时不创建内存空间，令其指向null //使用避免指令重排带来的线程安全问题 private static volatile GiantDragon instance; //public static 方法，返回实例对象 //，使用同步代码块提高效率 //现在不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率 public static GiantDragon getInstance(){ //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance){ synchronized (GiantDragon.class){ if(null==instance){ instance = new GiantDragon(); } } } //返回 instance指向的对象 return instance; } } 四、静态内部类实现 使用静态内部类解决了线程安全问题，并实现了延时加载 缺点：反射机制有可能会破坏单例化 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //不会在外部类初始化时就直接加载，只有当调用了getInstance方法时才会静态加载，线程安全，final保证了在内存中只有一份 private static class InnerClass{ private static final SingletonDemo4 instance = new SingletonDemo4(); } public static SingletonDemo4 getInstance() { return InnerClass.instance; } } 五、枚举单例 最推荐使用的单例模式 特点：线程安全，调用效率高 缺点：不能延时加载（但是安全） //枚举方式实现单例模式 public enum SingletonDemo5 { INSTANCE; public static SingletonDemo5 getInstance() { return INSTANCE; } } class SingletonDemo5Test { public static void main(String[] args) { SingletonDemo5 instance = SingletonDemo5.getInstance(); SingletonDemo5 instance1 = SingletonDemo5.getInstance(); System.out.println(instance == instance1); //true } }","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://lorz5.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lorz5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java中的泛型","slug":"Java中的泛型","date":"2020-03-12T12:28:55.000Z","updated":"2020-04-09T09:20:52.531Z","comments":true,"path":"2020/03/12/Java中的泛型/","link":"","permalink":"https://lorz5.github.io/2020/03/12/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"Java中的泛型泛型是一种参数化类型的机制。它可以使得代码适用于各种类型，从而编写更加通用的代码，例如集合框架。 泛型是一种编译时类型确认机制。它提供了编译期的类型安全，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException（类型转换错误异常） 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 一、使用泛型与不使用泛型的集合的区别1、不使用泛型的集合优点：集合不使用泛型，默认是Object类型，可以存储任何类型的元素 缺点：不安全，会引发异常 import java.util.ArrayList; public class leeCode { public static void main(String[] args) { ArrayList e = new ArrayList(); // 可以往集合里添加任意类型的元素 e.add(\"字符串\"); e.add(1); // 因为无法确定集合里的对象类型，所以使用每个对象独有的方法 // 会抛出异常 for (Object k : e) { String s = (String)k; System.out.println(s.length()); } } } 2、使用泛型的集合优点：避免了类型转换的麻烦，存取元素类型一致 缺点：指定了什么类型，就只能是什么类型，无法存入其他元素 import java.util.ArrayList; public class leeCode { public static void main(String[] args) { // 使用泛型指定了集合存储的类型为String ArrayList&lt;String> e = new ArrayList&lt;String>(); e.add(\"字符串1\"); // e.add(1); error：只能存储字符串 e.add(\"字符串2\"); for (String k : e) { System.out.println(k.length()); } } } 二、泛型的定义跟使用作用：简单来说就是使一个类或者方法具有兼容性，可以根据我们需要的数据类型对某一种数据类型进行操作 1、定义和使用带有泛型的类格式： 修饰符 class 类名&lt;泛型变量&gt; { } Ex： /* API中的ArrayList集合 */ // E 代表一个未知的数据类型 class ArrayList&lt;E> { public boolean add(E e) { // 方法体 } public E get(int index) { // 方法体 } } 什么时候确定泛型？ 创建对象的时候确认泛型的类型 2、定义和使用带有泛型的方法格式： 修饰符 &lt;泛型变量&gt; 返回值类型 方法名称 (参数){ } Ex: public class GenericMethodTest { // 泛型方法 printArray // 一个方法实现对多种数据类型的数据输出的功能，具备了一定的兼容性 public static < E > void printArray( E[] inputArray ) { // 输出数组元素 for ( E element : inputArray ){ System.out.printf( \"%s \", element ); } System.out.println(); } public static void main( String args[] ) { // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = { 1, 2, 3, 4, 5 }; Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; Character[] charArray = { 'H', 'E', 'L', 'L', 'O' }; System.out.println( \"整型数组元素为:\" ); printArray( intArray ); // 传递一个整型数组 System.out.println( \"\\n双精度型数组元素为:\" ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( \"\\n字符型数组元素为:\" ); printArray( charArray ); // 传递一个字符型数组 } } 什么时候确定泛型？ 调用方法的时候确认泛型的类型 3、定义和使用带有泛型的接口 定义和使用含有泛型的类、接口、泛型通配符————————墨白 因为（继承）实现接口的时候对于泛型有两种情况，所以单独拿出来讨论。 当接口定义了泛型的时候，可以 1.实现（继承）时，保留接口（父类）的,这样相当于实现类（子类）也使用了泛型，在创建对象的时候确定泛型的数据类型。 2.实现（继承）时，直接把接口（父类）的写成想要实现的数据类型。 1、接口使用泛型 public interface MyInterFace&lt;E> { public abstract E func1(); public abstract E func2(); public abstract E func3(); } 2、实现时指定是什么数据类型 public class MyImple implements MyInterFace&lt;String> { public String func1(){ System.out.println(\"fun1\"); } public String func2(){ System.out.println(\"fun2\"); } public String func3(){ System.out.println(\"fun3\"); } } 或者实现类依旧带泛型 public class MyImple&lt;E> implements MyInterFace&lt;E> { public E func1(){ System.out.println(\"fun1\"); return null; } public E func2(){ System.out.println(\"fun2\"); return null; } public E func3(){ System.out.println(\"fun3\"); return null; } } 三、泛型通配符 类型通配符一般是使用 ? *代替具体的类型参数。例如 *List 在逻辑上是List，List** 等所有List&lt;具体类型实参&gt;的父类。 import java.util.*; public class GenericTest { public static void main(String[] args) { List&lt;String> name = new ArrayList&lt;String>(); List&lt;Integer> age = new ArrayList&lt;Integer>(); List&lt;Number> number = new ArrayList&lt;Number>(); name.add(\"icon\"); age.add(18); number.add(314); getData(name); getData(age); getData(number); } // 因为getData()方法的参数是List类型的，所以name，age，number都可以作为这个方法的实参，这就是通配符的作用 public static void getData(List&lt;?> data) { System.out.println(\"data :\" + data.get(0)); } } 类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。 import java.util.*; public class GenericTest { public static void main(String[] args) { List&lt;String> name = new ArrayList&lt;String>(); List&lt;Integer> age = new ArrayList&lt;Integer>(); List&lt;Number> number = new ArrayList&lt;Number>(); name.add(\"icon\"); age.add(18); number.add(314); // 1报错，因为getUperNumber()方法中的参数已经限定了参数泛型上限为Number，所以泛型为String是不在这个范围之内，所以会报错 //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 } public static void getData(List&lt;?> data) { System.out.println(\"data :\" + data.get(0)); } public static void getUperNumber(List&lt;? extends Number> data) { System.out.println(\"data :\" + data.get(0)); } } 类型通配符下限通过形如 List来定义，表示类型只能接受Number及其三层父类类型，如 Object 类型的实例。","categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"}]}],"categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://lorz5.github.io/tags/c/"},{"name":"底层","slug":"底层","permalink":"https://lorz5.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"},{"name":"doc","slug":"doc","permalink":"https://lorz5.github.io/tags/doc/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lorz5.github.io/tags/MySQL/"},{"name":"java","slug":"java","permalink":"https://lorz5.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lorz5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}