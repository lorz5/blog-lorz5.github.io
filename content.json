{"meta":{"title":"lorz5の小さい家","subtitle":"Personal Website","description":"ー頑張ろうねー","author":"lorz5","url":"https://lorz5.github.io","root":"/"},"pages":[{"title":"about","date":"2020-04-01T07:23:25.000Z","updated":"2020-04-01T07:25:31.498Z","comments":true,"path":"about/index.html","permalink":"https://lorz5.github.io/about/index.html","excerpt":"","text":"一个渴望能飞起来的小蚂蚁 正在努力向前爬…"},{"title":"404","date":"2020-04-01T02:00:45.000Z","updated":"2020-04-01T02:00:45.830Z","comments":true,"path":"404/index.html","permalink":"https://lorz5.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2020-04-01T02:00:33.000Z","updated":"2020-04-01T02:00:33.237Z","comments":true,"path":"search/index.html","permalink":"https://lorz5.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"Java中的匿名内部类","slug":"Java中的匿名内部类","date":"2020-04-08T14:59:54.000Z","updated":"2020-04-08T15:51:23.808Z","comments":true,"path":"2020/04/08/Java中的匿名内部类/","link":"","permalink":"https://lorz5.github.io/2020/04/08/Java%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"Java中的匿名内部类与代码块代码块用途：用于初始化类成员属性 具体使用方法： public class Main { public int age; public static String name; // 非静态代码块 { age = 1; double money = 100; System.out.println(\"~执行了非静态代码块~\"); } // 静态代码块 static { // age = 10; // error，静态代码块只能对静态属性进行操作 name = \"lorz5\"; System.out.println(\"~执行了静态代码块~\"); } public static void main(String[] args) { // 实例化两次，静态代码块只会初始化一次 Main a = new Main(); Main b = new Main(); } } /* 输出结果： > ~执行了静态代码块~ > ~执行了非静态代码块~ > ~执行了非静态代码块~ */ 静态代码块只能对静态属性进行操作 静态代码块只会初始化一次 静态代码块优先于非静态代码块 匿名内部类匿名内部类即没有名字的内部类，只能使用一次 前提条件：必须继承一个父类或实现一个接口 用途：简化代码编写 使用方法1、匿名内部类实现抽象方法abstract class A { int num; public abstract void say(); } public class Main { public static void main(String[] args) { // 创建的匿名内部类为A的子类 A aa = new A() { {// 因为没有类名，所以没有构造函数，作为代替，可以使用代码块来初始化 super.num = 1; } public void say(){ System.out.println(\"Hello\"); } }; aa.say(); } } /* 输出结果： > Hello */ 2、匿名内部类实现接口interface A { void say(); } public class Main { public static void main(String[] args) { A aa = new A() { public void say(){ System.out.println(\"Hello\"); } }; aa.say(); } } /* 输出结果： > Hello */ 3、Thread类的匿名内部类实现public class Demo { public static void main(String[] args) { Thread t = new Thread() { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.print(i + \" \"); } } }; t.start(); } } /* 输出结果： > 1 2 3 4 5 */ 4、Runnable接口的匿名内部类实现public class Demo { public static void main(String[] args) { Runnable r = new Runnable() { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.print(i + \" \"); } } }; Thread t = new Thread(r); t.start(); } } /* 输出结果： > 1 2 3 4 5 */","categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"}]},{"title":"Java中的equals方法","slug":"Java中的equals方法","date":"2020-04-08T12:21:32.000Z","updated":"2020-04-08T12:49:38.929Z","comments":true,"path":"2020/04/08/Java中的equals方法/","link":"","permalink":"https://lorz5.github.io/2020/04/08/Java%E4%B8%AD%E7%9A%84equals%E6%96%B9%E6%B3%95/","excerpt":"","text":"java中的equals方法小结Java中比较两个对象有两种方式 一、==操作符 这个用来比较两个对象是否为同一对象 原理：实质比较的是变量(栈)内存中存放的对象的(堆)内存地址 真正意义上的指针操作。 public class Main { public static void main(String[] args) { Father a = new Father(); Father b = new Father(); System.out.println(a == b); // false，不是同一对象 } } 二、equals()方法 涉及到的常识：所有类都继承Object，也就拥有了从Object中得到的equals()方法 /* 底层源码 */ public boolean equals(Object obj) { return (this == obj); } 传统的equals()方法与==操作符作用一样，只能比较是否指向同一对象 特例：当用equals()方法进行比较时，对File、Date和各种包装类（Integer、Double、String等等）来说，比较的是类型和内容是否一致而不考虑引用的是否是同一对象（原因：重写了equals()方法） public class Main { public static void main(String[] args) { String a = new String(\"123\"); String b = new String(\"123\"); System.out.println(a == b); // false，不同的两个对象 System.out.println(a.equals(b)); // true，两个对象内容相同 } } 三、补充小知识 java中的jvm将内存粗略的分成三个区，分别为栈区、堆区和常量池 变量存放的内存为栈区，动态分配的内存（new）的则在堆区 定义的常量只会存在一个，存放在常量池中 public class Main { public static void main(String[] args) { String a = \"abc\"; // 在常量池中创建了一个\"abc\"的对象 String b = \"abc\"; // 常量池中已存在同样的为“abc”的对象，直接将其赋给当前引用 System.out.println(a == b); // true，同一个对象 System.out.println(a.equals(b)); // true，两个对象内容相同 } } 另外，==比较运算比使用equals()方法快","categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"}]},{"title":"常用doc命令","slug":"常用doc命令","date":"2020-04-06T16:25:45.000Z","updated":"2020-04-06T16:31:36.172Z","comments":true,"path":"2020/04/07/常用doc命令/","link":"","permalink":"https://lorz5.github.io/2020/04/07/%E5%B8%B8%E7%94%A8doc%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用的doc命令dir：列出当前目录下的文件以及文件夹 md：创建一个文件夹 rd：删除一个文件夹 cd：进入指定目录 cd..：返回上一级目录 cd\\：退回到根目录 del：删除文件 exit：退出doc命令行","categories":[],"tags":[{"name":"doc","slug":"doc","permalink":"https://lorz5.github.io/tags/doc/"}]},{"title":"开始学习MySQL","slug":"开始学习MySQL","date":"2020-04-03T12:09:06.000Z","updated":"2020-04-03T15:58:34.329Z","comments":true,"path":"2020/04/03/开始学习MySQL/","link":"","permalink":"https://lorz5.github.io/2020/04/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0MySQL/","excerpt":"","text":"MySQL一、从安装开始 安装地址：https://dev.mysql.com/downloads/mysql/ 1、挑选合适的版本安装（建议以压缩包的形式） 2、建议放在电脑的环境配置下 3、配置环境变量 我的电脑 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; Path路径 -&gt; 编辑，添加bin目录 4、新建mysql配置文件 [mysqld] basedir=D:\\Environment\\mysql-8.0.19\\ datadir=D:\\Environment\\mysql-8.0.19\\data\\ port=3306 #端口 skip-grant-tables #跳过密码验证 5、启动管理员模式下的CMD，切换到mysql下的bin目录，输入mysqld -install （安装mysql）","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lorz5.github.io/tags/MySQL/"}]},{"title":"23种设计模式之单例模式","slug":"23种设计模式之单例模式","date":"2020-04-01T08:11:23.000Z","updated":"2020-04-01T08:19:43.818Z","comments":true,"path":"2020/04/01/23种设计模式之单例模式/","link":"","permalink":"https://lorz5.github.io/2020/04/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式参考： https://how2j.cn/k/class-object/class-object-singleton/349.html#nowhere https://www.bilibili.com/video/av68172551 https://blog.csdn.net/baolingye/article/details/101106783 核心作用 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点 优点 单例模式只生成一个实例，减少系统的性能开销 单例模式可以在系统设置全局访问点，优化共享资源访问 常见的五种单例模式实现一、饿汉式 特点：线程安全，调用效率高，不能延时加载 缺点：无论这个类有没有被调用到，都会首先加载里面的资源，占用一定的内存空间，如果这个类长时间没有被用到，那么容易会造成空间浪费的结果。 /* 精髓所在 */ public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取第7行定义的对象 public static GiantDragon getInstance(){ return instance; } } /* 测试，后面相同 */ public class TestGiantDragon { public static void main(String[] args) { //通过new实例化会报错 // GiantDragon g = new GiantDragon(); //只能通过getInstance得到对象 GiantDragon g1 = GiantDragon.getInstance(); GiantDragon g2 = GiantDragon.getInstance(); GiantDragon g3 = GiantDragon.getInstance(); //都是同一个对象 System.out.println(g1==g2); // true System.out.println(g1==g3); // true } } 二、懒汉式 懒汉式单例模式与饿汉式单例模式不同，只有在调用这个类的时候，才会创建实例 特点：线程安全，调用效率不高，可以延时加载 缺点：效率较低 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //准备一个类属性，用于指向一个实例化对象，但是暂时不创建内存空间，令其指向null private static GiantDragon instance; //public static 方法，返回实例对象 // 若存在并发，可添加synchronized修饰符 public static GiantDragon getInstance(){ //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance){ instance = new GiantDragon(); } //返回 instance指向的对象 return instance; } } 三、DCL懒汉式（双重检测锁模式） 特点：不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率 缺点：因为不是在类加载时就创建对象，因此存在线程安全问题，当第一个线程执行到创建对象的方法时，但还未出方法返回，此时第二个线程进入，发现instance不为空，但第一个线程此时还未出去，可能发送意想不到的安全问题 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //准备一个类属性，用于指向一个实例化对象，但是暂时不创建内存空间，令其指向null //使用避免指令重排带来的线程安全问题 private static volatile GiantDragon instance; //public static 方法，返回实例对象 //，使用同步代码块提高效率 //现在不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率 public static GiantDragon getInstance(){ //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance){ synchronized (GiantDragon.class){ if(null==instance){ instance = new GiantDragon(); } } } //返回 instance指向的对象 return instance; } } 四、静态内部类实现 使用静态内部类解决了线程安全问题，并实现了延时加载 缺点：反射机制有可能会破坏单例化 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){ } //不会在外部类初始化时就直接加载，只有当调用了getInstance方法时才会静态加载，线程安全，final保证了在内存中只有一份 private static class InnerClass{ private static final SingletonDemo4 instance = new SingletonDemo4(); } public static SingletonDemo4 getInstance() { return InnerClass.instance; } } 五、枚举单例 最推荐使用的单例模式 特点：线程安全，调用效率高 缺点：不能延时加载（但是安全） //枚举方式实现单例模式 public enum SingletonDemo5 { INSTANCE; public static SingletonDemo5 getInstance() { return INSTANCE; } } class SingletonDemo5Test { public static void main(String[] args) { SingletonDemo5 instance = SingletonDemo5.getInstance(); SingletonDemo5 instance1 = SingletonDemo5.getInstance(); System.out.println(instance == instance1); //true } }","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://lorz5.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lorz5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[],"tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"https://lorz5.github.io/tags/JavaSe/"},{"name":"doc","slug":"doc","permalink":"https://lorz5.github.io/tags/doc/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lorz5.github.io/tags/MySQL/"},{"name":"java","slug":"java","permalink":"https://lorz5.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lorz5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}