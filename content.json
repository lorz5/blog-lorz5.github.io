{"meta":{"title":"lorz5の小さい家","subtitle":"Personal Website","description":"ー頑張ろうねー","author":"lorz5","url":"https://lorz5.github.io","root":"/"},"pages":[{"title":"about","date":"2020-04-01T07:23:25.000Z","updated":"2020-04-01T07:25:31.498Z","comments":true,"path":"about/index.html","permalink":"https://lorz5.github.io/about/index.html","excerpt":"","text":"一个渴望能飞起来的小蚂蚁 正在努力向前爬…"},{"title":"404","date":"2020-04-01T02:00:45.000Z","updated":"2020-04-01T02:00:45.830Z","comments":true,"path":"404/index.html","permalink":"https://lorz5.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2020-04-01T02:00:33.000Z","updated":"2020-04-01T02:00:33.237Z","comments":true,"path":"search/index.html","permalink":"https://lorz5.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"23种设计模式之单例模式","slug":"23种设计模式之单例模式","date":"2020-04-01T08:11:23.000Z","updated":"2020-04-01T08:19:43.818Z","comments":true,"path":"2020/04/01/23种设计模式之单例模式/","link":"","permalink":"https://lorz5.github.io/2020/04/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式参考： https://how2j.cn/k/class-object/class-object-singleton/349.html#nowhere https://www.bilibili.com/video/av68172551 https://blog.csdn.net/baolingye/article/details/101106783 核心作用 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点 优点 单例模式只生成一个实例，减少系统的性能开销 单例模式可以在系统设置全局访问点，优化共享资源访问 常见的五种单例模式实现一、饿汉式 特点：线程安全，调用效率高，不能延时加载 缺点：无论这个类有没有被调用到，都会首先加载里面的资源，占用一定的内存空间，如果这个类长时间没有被用到，那么容易会造成空间浪费的结果。 12345678910111213141516/* 精髓所在*/public class GiantDragon &#123; //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取第7行定义的对象 public static GiantDragon getInstance()&#123; return instance; &#125;&#125; 123456789101112131415161718/* 测试，后面相同*/public class TestGiantDragon &#123; public static void main(String[] args) &#123; //通过new实例化会报错// GiantDragon g = new GiantDragon(); //只能通过getInstance得到对象 GiantDragon g1 = GiantDragon.getInstance(); GiantDragon g2 = GiantDragon.getInstance(); GiantDragon g3 = GiantDragon.getInstance(); //都是同一个对象 System.out.println(g1==g2); // true System.out.println(g1==g3); // true &#125;&#125; 二、懒汉式 懒汉式单例模式与饿汉式单例模式不同，只有在调用这个类的时候，才会创建实例 特点：线程安全，调用效率不高，可以延时加载 缺点：效率较低 12345678910111213141516171819public class GiantDragon &#123; //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //准备一个类属性，用于指向一个实例化对象，但是暂时不创建内存空间，令其指向null private static GiantDragon instance; //public static 方法，返回实例对象 // 若存在并发，可添加synchronized修饰符 public static GiantDragon getInstance()&#123; //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance)&#123; instance = new GiantDragon(); &#125; //返回 instance指向的对象 return instance; &#125; &#125; 三、DCL懒汉式（双重检测锁模式） 特点：不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率 缺点：因为不是在类加载时就创建对象，因此存在线程安全问题，当第一个线程执行到创建对象的方法时，但还未出方法返回，此时第二个线程进入，发现instance不为空，但第一个线程此时还未出去，可能发送意想不到的安全问题 1234567891011121314151617181920212223242526public class GiantDragon &#123; //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //准备一个类属性，用于指向一个实例化对象，但是暂时不创建内存空间，令其指向null //使用避免指令重排带来的线程安全问题 private static volatile GiantDragon instance; //public static 方法，返回实例对象 //，使用同步代码块提高效率 //现在不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率 public static GiantDragon getInstance()&#123; //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance)&#123; synchronized (GiantDragon.class)&#123; if(null==instance)&#123; instance = new GiantDragon(); &#125; &#125; &#125; //返回 instance指向的对象 return instance; &#125; &#125; 四、静态内部类实现 使用静态内部类解决了线程安全问题，并实现了延时加载 缺点：反射机制有可能会破坏单例化 123456789101112131415public class GiantDragon &#123; //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //不会在外部类初始化时就直接加载，只有当调用了getInstance方法时才会静态加载，线程安全，final保证了在内存中只有一份 private static class InnerClass&#123; private static final SingletonDemo4 instance = new SingletonDemo4(); &#125; public static SingletonDemo4 getInstance() &#123; return InnerClass.instance; &#125; &#125; 五、枚举单例 最推荐使用的单例模式 特点：线程安全，调用效率高 缺点：不能延时加载（但是安全） 12345678910111213141516//枚举方式实现单例模式public enum SingletonDemo5 &#123; INSTANCE; public static SingletonDemo5 getInstance() &#123; return INSTANCE; &#125;&#125;class SingletonDemo5Test &#123; public static void main(String[] args) &#123; SingletonDemo5 instance = SingletonDemo5.getInstance(); SingletonDemo5 instance1 = SingletonDemo5.getInstance(); System.out.println(instance == instance1); //true &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://lorz5.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lorz5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://lorz5.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lorz5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}